package com.contentgrid.appserver.domain.data.type;

import com.contentgrid.appserver.application.model.attributes.Attribute;
import com.contentgrid.appserver.application.model.attributes.CompositeAttribute;
import com.contentgrid.appserver.application.model.attributes.SimpleAttribute;
import com.contentgrid.appserver.application.model.relations.ManyToManyRelation;
import com.contentgrid.appserver.application.model.relations.ManyToOneRelation;
import com.contentgrid.appserver.application.model.relations.OneToManyRelation;
import com.contentgrid.appserver.application.model.relations.OneToOneRelation;
import com.contentgrid.appserver.application.model.relations.Relation;
import com.contentgrid.appserver.domain.data.DataEntry;
import lombok.NonNull;

/**
 * Describes the type of a {@link DataEntry}
 */
public sealed interface DataType permits ObjectDataType, RelationDataType, RelationListDataType,
        TechnicalDataType {

    /**
     * Construct a type based on the class of a {@link DataEntry}
     * <p>
     * The type description generated by using the class is inherently less specific than the one created by {@link #of(DataEntry)},
     * especially for more complex data types like objects and relations
     *
     * @param dataEntryClass The data entry class to create a type for
     */
    static DataType of(@NonNull Class<? extends DataEntry> dataEntryClass) {
        return DataEntryDataType.of(dataEntryClass);
    }

    /**
     * Construct a type based on a {@link DataEntry}
     * <p>
     * The created type description can expose some additional data,
     * like the keys of an {@link com.contentgrid.appserver.domain.data.DataEntry.MapDataEntry},
     * or the target entity of a {@link com.contentgrid.appserver.domain.data.DataEntry.AnyRelationDataEntry}
     *
     * @param dataEntry The data entry to create a type for
     */
    static DataType of(@NonNull DataEntry dataEntry) {
        return DataEntryDataType.of(dataEntry);
    }

    /**
     * Construct a type based on the type of a {@link SimpleAttribute}
     */
    static DataType of(@NonNull SimpleAttribute.Type type) {
        return switch (type) {
            case LONG -> TechnicalDataType.LONG;
            case DOUBLE -> TechnicalDataType.DECIMAL;
            case BOOLEAN -> TechnicalDataType.BOOLEAN;
            case TEXT, UUID -> TechnicalDataType.STRING;
            case DATETIME -> TechnicalDataType.DATETIME;
        };
    }

    /**
     * Construct a map-type based on a {@link CompositeAttribute}
     */
    static DataType of(@NonNull CompositeAttribute compositeAttribute) {
        return ObjectDataType.of(compositeAttribute);
    }

    /**
     * Construct a type based on an {@link Attribute}.
     * <p>
     * This automatically determines the type of attribute and creates a data type from it.
     * {@link SimpleAttribute} map directly to their declared datatype; {@link CompositeAttribute} map to an object type with the nested attributes as declared keys
     */
    static DataType of(@NonNull Attribute attribute) {
        return switch (attribute) {
            case CompositeAttribute compositeAttribute -> of(compositeAttribute);
            case SimpleAttribute simpleAttribute -> of(simpleAttribute.getType());
        };
    }

    /**
     * Construct a type based on a {@link Relation}
     * <p>
     * This automatically determines the arity of the relation and creates a data type from it that includes the targeted entity name
     */
    static DataType of(@NonNull Relation relation) {
        var targetName = relation.getTargetEndPoint().getEntity();
        return switch (relation) {
            case OneToOneRelation ignored -> RelationDataType.to(targetName);
            case ManyToOneRelation ignored -> RelationDataType.to(targetName);
            case OneToManyRelation ignored -> RelationListDataType.to(targetName);
            case ManyToManyRelation ignored -> RelationListDataType.to(targetName);
        };
    }

    String getTechnicalName();

    String getHumanDescription();
}
